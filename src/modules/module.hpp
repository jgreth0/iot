
#ifndef _MODULE_H_
#define _MODULE_H_

#include "unit.hpp"
#include <thread>
#include <condition_variable>
#include <set>

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
class module : public unit {
private:
    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    std::mutex mtx, listeners_mtx;
    std::condition_variable cv_mt, cv_wt;

    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    bool automatic = true, default_update = true;
    int update_frequency;
    std::vector<int> key_times;

    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    bool done = false, skip_wait = false;

    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    bool mt_exit = false, heart_beat_requested = false;
    uint64_t sync_start_count = 0, sync_finish_count = 0;
    time_point next_sync_time, heart_beat_request_time;

    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    std::thread thread;
    static void management_thread(module* m);

    ////////////////////////////////////////////////////////////////////////////
    // Listen
    ////////////////////////////////////////////////////////////////////////////
    std::set<module*> listeners;

protected:
    ////////////////////////////////////////////////////////////////////////////
    // The derived class implements the sync capability and any required
    // setters and getters. The derived class is expected to protect its own
    // state against race conditions.
    ////////////////////////////////////////////////////////////////////////////
    virtual void sync(bool last = false);

    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    void set_sync_time(time_point tp);

    ////////////////////////////////////////////////////////////////////////////
    // Listen
    ////////////////////////////////////////////////////////////////////////////
    void notify_listeners();

    void add_key_time(int min);
    int get_key_id(time_point current_time);
    time_point get_key_time(time_point current_time, int id = -1);

public:
    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    module(bool automatic = true, int update_frequency = 1);

    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    virtual void enable();

    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    virtual void disable();

    ////////////////////////////////////////////////////////////////////////////
    // sync_wait() triggers a call to sync() and blocks until that call
    // completes. If there is a sync() in progress, it waits for that sync()
    // to complete and then launches another sync so that a full cycle is
    // completed before returning.
    // Any number of users of this module can call sync_wait() concurrently.
    ////////////////////////////////////////////////////////////////////////////
    void sync_wait();

    ////////////////////////////////////////////////////////////////////////////
    // sync_now() triggers a call to sync() and returns immediately. If
    // there is a sync() in progress, another sync() call is scheduled to
    // begin immediately upon return of the current call.
    ////////////////////////////////////////////////////////////////////////////
    void sync_now();

    ////////////////////////////////////////////////////////////////////////////
    // heart_beat_wait() requests an immediate heart beat and waits until it
    // completes. Any number of users of this module can call heart_beat_wait()
    // concurrently.
    ////////////////////////////////////////////////////////////////////////////
    void heart_beat_wait();

    ////////////////////////////////////////////////////////////////////////////
    // heart_beat_now() requests an immediate heart beat and then returns
    // without waiting.
    ////////////////////////////////////////////////////////////////////////////
    void heart_beat_now();

    ////////////////////////////////////////////////////////////////////////////
    // Answers: How long has the heart beat been missing for? If no heart beat
    // was requested, returns zero duration.
    ////////////////////////////////////////////////////////////////////////////
    duration heart_beat_missed();

    ////////////////////////////////////////////////////////////////////////////
    // Listen
    ////////////////////////////////////////////////////////////////////////////
    void listen(module* m);

    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    void unlisten(module* m);
};

#endif
