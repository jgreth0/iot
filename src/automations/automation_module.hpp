
#ifndef _AUTOMATION_MODULE_H_
#define _AUTOMATION_MODULE_H_

#include "../modules/module.hpp"
#include <vector>

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
class automation_module : public module {
private:
    ////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////
    std::mutex mtx;
    std::vector<automation*> automations;
protected:

    ////////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////////
    void sync(bool last) {
        if (last) return;
        std::unique_lock<std::mutex> lck(mtx);
        time_point current_time = now_floor();
        for (int i = 0; i < automations.size(); i++)
            automations[i]->sync(current_time);
    }
public:
    ////////////////////////////////////////////////////////////////////////////////
    //
    ////////////////////////////////////////////////////////////////////////////////
    automation_module() : module(true, 60) {
        char name[64];
        snprintf(name, 64, "automation_module");
        set_name(name);
        report("constructor called", 5);
    }

    void add_automation(automation* a) {
        std::unique_lock<std::mutex> lck(mtx);
        automations.push_back(a);
    }
};

#endif
